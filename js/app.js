// Generated by CoffeeScript 1.6.2
(function() {
  var CanvasManager, DragHandle, RangeIndicator, SpectrumDisplay, loadSound, root;

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  CanvasManager = root.CanvasManager;

  DragHandle = root.DragHandle;

  RangeIndicator = root.RangeIndicator;

  SpectrumDisplay = root.SpectrumDisplay;

  loadSound = function(context, url, callback) {
    var request;

    request = new XMLHttpRequest();
    request.open('GET', url, true);
    request.responseType = 'arraybuffer';
    request.onload = function() {
      return context.decodeAudioData(request.response, callback);
    };
    return request.send();
  };

  $(document).ready(function() {
    var bandPassInd, calculateBandPass, canvas, context, handle1, handle2, mgr, noiseBuffer, onLoaded, setup, specDisplay, toLoad, voiceBuffer;

    window.scrollTo(0, 1);
    context = new webkitAudioContext();
    voiceBuffer = null;
    noiseBuffer = null;
    canvas = $('canvas');
    mgr = new CanvasManager(canvas);
    specDisplay = new SpectrumDisplay(25, 0, 700, 200);
    mgr.add(specDisplay);
    handle1 = new DragHandle(0, 250, 50, 50, "#3EA828", {
      minX: 0,
      maxX: 600
    });
    handle2 = new DragHandle(400, 250, 50, 50, "#3EA828", {
      minX: 0,
      maxX: 600
    });
    bandPassInd = new RangeIndicator(0, 200, "#3EA828", handle1, handle2);
    mgr.render();
    toLoad = 2;
    onLoaded = function() {
      toLoad--;
      if (toLoad === 0) {
        return setup();
      }
    };
    loadSound(context, 'atlys.mp3', function(buffer) {
      voiceBuffer = buffer;
      return onLoaded();
    });
    loadSound(context, 'noise.mp3', function(buffer) {
      noiseBuffer = buffer;
      return onLoaded();
    });
    calculateBandPass = function() {
      var Q, delta, f1, f2, freq, x1, x2, _ref;

      x1 = handle1.getMarkerX();
      x2 = handle2.getMarkerX();
      if (x1 > x2) {
        _ref = [x2, x1], x1 = _ref[0], x2 = _ref[1];
      }
      f1 = specDisplay.convertXtoF(x1, context.sampleRate);
      f2 = specDisplay.convertXtoF(x2, context.sampleRate);
      delta = f2 - f1;
      freq = (f1 + f2) / 2;
      Q = freq / delta;
      return [freq, Q];
    };
    return setup = function() {
      var freq, intervalId, pipeline, playing, _i, _len, _ref;

      pipeline = new AudioPipeline(context, noiseBuffer);
      specDisplay.analyser = pipeline.postAnalyser;
      pipeline.setInterference(1500, 1, [900, 1100, 1300, 1500, 1700, 1900]);
      handle1.onMove = handle2.onMove = function() {
        var Q, freq, _ref;

        _ref = calculateBandPass(), freq = _ref[0], Q = _ref[1];
        pipeline.bandPass.setFrequency(freq);
        return pipeline.bandPass.setQ(Q);
      };
      _ref = [900, 1100, 1300, 1500, 1700, 1900];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        freq = _ref[_i];
        pipeline.toneFilter.addFrequency(freq);
      }
      playing = false;
      intervalId = null;
      $('#play-button').click(function() {
        if (playing) {
          playing = false;
          $(this).text("Play");
          pipeline.stop();
          return clearInterval(intervalId);
        } else {
          playing = true;
          $(this).text("Stop");
          pipeline.play(voiceBuffer);
          return intervalId = setInterval(function() {
            return mgr.render();
          }, 30);
        }
      });
      $('#show-output-spectrum').change(function() {
        if (this.checked) {
          return specDisplay.analyser = pipeline.postAnalyser;
        } else {
          return specDisplay.analyser = pipeline.preAnalyser;
        }
      });
      return $('#enable-band-pass').change(function() {
        var Q, _ref1;

        if (this.checked) {
          mgr.add(handle1, true);
          mgr.add(handle2, true);
          mgr.add(bandPassInd);
          _ref1 = calculateBandPass(), freq = _ref1[0], Q = _ref1[1];
          return pipeline.bandPass.set(2, 8, freq, Q);
        } else {
          mgr.remove(handle1);
          mgr.remove(handle2);
          mgr.remove(bandPassInd);
          return pipeline.bandPass.clear();
        }
      });
    };
  });

}).call(this);
